<meta charset=iso-8859-1>
<title>Geoquiz2</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="mobile-web-app-capable" content="yes">
<meta name="format-detection" content="telephone=no">
<meta name="msapplication-tap-highlight" content="no">

<body id=b>
<canvas id=a height=575>

<script>


// Note: this file is encoded in ANSI, in order to encode every byte of the game's data on a 1-byte char.

// These globals are just to inform the minifier what a, b and C-M are. Don't put them in the final file.

//b=document.body;
//a=document.createElement("canvas");
//C=D=E=F=G=H=I=J=K=L=M="";


// DATA (binary)
// =============

// countries 
C = `õ2£L22|}c	,I9h_br"):
+CTAKBKBLRK9OOKAROVa1LaJaJ,IZrDIyMT)IrJZA:GZnyIk	qiqczë5J¡Q‰
AË
@Â6n#+ZCY	A©CQJT§H ÀJXÁ\rAJa°Pßx™
~”N÷7bQc[O:B;R[jSrj
jzy%:I9
%Q;1œmhX8~KE=?sa 
!qa8I8 AY!1A39aQ2BJrYiQqa:)ID0A#(
"Ja:a2AKiXzY)AqXKARJAIAMSCoi	y}izHz(U-J	A1IK80*
.\ryQ0	@6
z0@Q6
P<RIWJSxOJ<	
YDRqbRz19
D;BDaG$XHLP8"5z1Y:qzL~Ç?Ç;a8PpIppXi
+áJh0~ÉT{c02bsjyV~WΩWΩ#S!Femcor"1#
!P›i
~ÍæÂölD!KaA^Tku
{hr&4Á«r)~å@åC!JZ~Ñ;Ç;8~_†[∫)#*;KE*U*WjQb{ivz[~ëJëL	(@Ji~ßg®eRy	~OªO£ucmcoziyD3*#+#*~åDåCpIq:~FiFi	PI0IA~ã=ä?0Y~â3à4P0(i	h~IãIë9)~ó^öjO.	qa1~í+ë+z @I~à*à*y,OU
]Sk~í)í)	3)@QJsRiy~ä8Ü6ch
02A~ëRëRHy(9 XIQhpìVHP	~éAéAQhIA~}NÇJxZbJ@ (!I(
x~ÜBÜAY
~Ä:Å;IQH"H9!a	Yqy{5p~q"ox
zSC~∑aƒ\`Zb2IrR]ib96!Q0 @	:!1yai	
~ÃìÃìX	L@Kÿô ÷ôHÀíA2=yiyŒà!	ixZhK1’í)y1I0
PIHha€áxh@›ãyq qX	+AY@1~•V£OQ@iya{qy
!9 29AYIA~†Y†SyaqXIC((~|5|5qR00h~ö\\ô\`1 ~âKâK:Y) 	azh8XpXhA(áMi(~JpJpH~„V„VQY@Qxa1	"qÂFYIX~öYöYPp~í4ë50H 
xa~Ö=Ö=~êKëL0Pi~¢•†¢jaq	&2b~;n.[

z|jz	!cHhY9PF)>1Xq|P<(~ÜHÜH~|X|X rUpK"~WÄWâ0)@!zhq~äZí\\AZDZpjy
~Ωb¡cJAI)~Ñ9Ñ7a	!~¸»¸»8 2{p^aJ¯“Hx~⁄P⁄K	xZpY8 @~ö\\ö\\~YÆU≠1!
szS)~JúPölHC59)yhQay~÷u÷u0!iXqH9Xa2aY (	◊ÄpiPxH0~è8ë5raJB2~zQzQy (!I~ìGïH @ 0JQq~•f•g8p~¢gô\`@yry	iUJ~ à à~ç@å@J~ãDäC	a~ïØè≥)y!jcZQK9 1 ~⁄S⁄Spa(1~ç+ç+bQ2!* rIaZhy~◊f◊fPi~àTá^2!ay~òOîK	yiQLPAXA1	@I~ñ<ë=(ihYQQAAa@8@QH@~YΩ[∫hYB#~JQJQ~Q{Q{zaxRpQ9!C)i8~äKäK~Àl…jpYzr\\)*: H~±W¨_ 8)	x	xJpaPhHY~ÇJÇJ~èLèO0 i~î6ì2hyPhXJA)~éHéFxa@1~Äx}xzYQJ~éÑåá2}PJhAXH~âÑáÉ x#qHqXrPK ~åêåê&(
qYkqYqxH8HB)@XH9J~}Ä{Ñ 8!x	paxI~E|D{z 0@~LÉIà*!hXhapYjB~Q¢O§")ihzPIaqCa~pupuor~òVòVXH~ÅÇÅÇ+yi~ÇÅÇÅ)0qah~ÀyÀ{A(	i~UtUt~åêåêR0*~OpOp	Bi~áäáájHY9~áÖáÖááp	8~Au?v(qX~MpNq)PpH~CvCw@IY~ö[ö[iIxY@~≥;£C9!*
z|bIiIqNYA1Q:QjC0~êJêJ@h~¢\`¢\` q~…p…jYq	r)9(H~õåúë;+y
k~»Ö»Ö1	sŒàyXIiR~{x}fPnKqz	!	+Q~ãUãU~ïBìAyY)~¥Y≠e!A
(0
RqaXRzQ9~H}F}
yh9Q@~âGâG~uuyxK0!	~èFêJA)h~®ë®ë•ò~°á•yf\\+C ~πÄπ|j~òtë}2,sf1Z~úîúë;Jkqy
~»w«Å1"3qrSaz~†tür
	qV~ñ§òß)BZ|~UqUq~†NüLz9~§N£OP9	yY~äóâítd1)	(A)HXH9~JfJfKg~§d§d~¡høe	rI~WwWw~BqBs0~¿cøc
Q~ì≠ê§
{[Ia1)~“É“É~ïèïèp~ãyå|3#)iZrU1~üõüõ†ú~üzüz Y~BwBw0X~ú}övd|
C0(C~útüx<b~ˇ§ˇ§@hˇ¢h~uwuw	@~†KùIq
A~ÄÇÅÇ*Qap~UyUy~w}w}0	zaA0~uyuxy~˚à˚à¸ã~µJ∫JNXR~í/ê1(	(Y@~îµîµxX~yÅxÅ!ha~àBàB~òûòû*sa~µÑµÑµä~˙Ä˙Ä˜}~up}fPnK0I3
"
(~©ß©ß~ÄÄÌÉÏÄ~ÃA”=a	yUYOE(:~éJèI@hq~òØó±*!)A(y1 
r]j~≈n¬k"bzZsh3Q~ç´ê§jXkQ@7(~˜ã˜ã~DyD{1b~Çwãx1#)JTkIPq~Ü}áÉ x#Oqah~™h•oq":ai~‡Ä‡Ä(p~ÈòÈò?Ik	ÍíY~ñçñç@i~TqTq~VvVv~UwUw~ûû~ÖäÖäÜà~w}w}ha~ÚòÚòx0ÛôPÛò8Òïx@~óÉöÇ9+[L|
~ZÇZÇIhq~öYöYp)Jax~±Q±S)qI@~ŸóŸó	Q~©©ß•~U{U{~™R¨V=RBt~ˇóˇó˝ì~òäïä(
jJh@~±M±MSi@=R*zy~¯§¯§˜†h0~ï†ì§I1)	(2j\\~©©\rù~	•	•
ß~ó∞ó∞Px`.split("~"),

// us states 
D = `èè0XìP)~+=&OOWMrUsbW
a})>K9;Zx/PAHS8p~7X5Ur+~9l:eKjzs	+X=~:k:k},M~GrJpMm
 
~\\}X}sa:2Q~WhYclY;0~]i[k*ia~hghg(~_v]t
S~O}JplK}!}"+KA*~ckaj
qP(~ardpiQAQI~Bh@e
ykK~bndp1AaS~\`m_ic~chajI*rP~gfheIh	~Zy[}J+
~PgIf)sN(~HjDp,N~\\w_}K+	z~\\bYe2IY~LYITk+~AYITlO<(~Aw?y+mI~TtRw*cJ~g\`f^	bH~fhfh:rXq~fb\`dz,H~hbgc#k~hchcIh
~ekekh~OsRw+Mj~>a=e/i{	k~7^=\\lN-~ZjYek	+~SeUaLs~QkKijN~M_I\\jN~[nWq	 a~ZrWqZM~U}Uxi	iIA*~j^l^2Qk~S]PTn2"C~VyU|)	kP8~WaVc
*8R0Kar~UmRq;K~HeI^kN+~`.split("~"),

// territories 
E = `_UOS{}w$*KC~Lˇy#[||ˇ~{biJbJ"~}U~Us~—j~Vu~®®~Áw~Gn~Tp~°¢¶§~}°~Tp~˜™P9~RpPSq~öõû~ZÇi
9~=~¥í¥ï~°ú~YC~Tp~ü~|&~S[~ãäâÇÅ	rb~≥÷XH p~Sp~Sq~OxPx~Ox~è)~fﬂpnÁnÈ~Qy~É‡~≈ú~Px~Àô~W⁄YV€ h~µ›~}5~>~–l~Ër~Tr~˜¥~%Ø&Æ)Æ~{X~ó~Nk~åCRJA`.split("~"),

// places
F = `Hac™”Nó]Ç?àGÇKÄ9LM”Nó]Ç?íQäKõ1Ñ;ÇEÄ?àF??1UÉG}TLM-XMMÇ?KQàF/S~NMLäKàGNùßfäK+?òd*Rßf*RîPÑ;¸¿íõ1ï°‚W∑\`äKòh…Ö3FIH∑\`ùké;Ä:8FKQéªÎªÇKãMÑ;4±GdCJâECJä1Ä9ïKMüéªÆX w¥Xà?µ[ö\\”ñBlíDïL›≠ä8ìS6O·Vö]rê8Åä`.match(/.{2}/g),

// lakes
G = `ECQ0K~ÖD~CFbpI~P¢8~óäa	)~(
QxI~ôòqi1~3$R8Y~Dyp~}/~÷t~ : paXQ~KGR
~÷s~EDxi@~óó9)~FLX~<:9iqX~ñ'yP~µF(
XI~ô"iy(8(~)I~Œe~.:~+R~,=`.split("~"),

// streams 
H = `_åRBZKARA~ó\\b{[qqY~âí#
vb~ÖÑ!;4R]~}Br~õß;JZ:*~±i*#~Ba;3!;(~0]+~'A$1y~Wº"	~ÿ]BZJAZR3D~’R[J+AbQIqJ~—k9IAQ!~•C!2*~ïK:J9)M:~É6ky~Ü4r~É8zX~ÑJ!0~Ä<y~ã¥y	~tp{aq~ÅÉ)A2~ävrz~tw~wa
9~}Ñ1!~ùë)9X~WΩ8*!~
(	!z{~höCQjd~üå1*8~ô±3IY~=fB1B2"@~\`ãZrYjb~W|Ua~=b3@~ {r	~Lyiqb~(@	!3~dçZiP~OA[R~Qàyy~XÄaq~€k[rZKRA[Si~Â5b[J=Jb~Ã}93:*3B~∫}k|sYj~≥Sj|Z{~¡l)1(~∆w*0+2C~£_B;A~™Fr{~¿l3K: ~±M)B:~ƒt+$~ÙWaZK~£_<)A~ÏRbRs~§P;Ia~ªt:IA~∫u8IA~¥k~Ãn1A~˛!AQ~£E;"=B[:~óD<*~õD A3~ßdzb	~ñF2K~yR	~é3j~ë.{	~‚ø	y
~ËèSx`.split("~"),

// deserts 
I = `ws3wWOOO~0W*zj~öav[U3~…N#[Ta~ﬂ∞K8Z~·∑3"|~M°t\\*!1 ~õ\`+{~ﬂ∞K<~å≥2 4{kr~4^<{kD:~ç™jcB~Qﬂ9)1Elcs~™R:|R~2_0Iq;*|i~ÆO9r~∂NjT~µi;j	~⁄Æ[:~™_
(y[I~≠ds~0WB)~¨YJ1~™_2
r`.split("~"),

// volcanoes
J = `ãRãL®®Vus!*BmãOAt÷s˘•◊v˜ œîùwAuˆˇ›ZïãÏënKÜÀë‘ñLÄ`.match(/.{2}/g),

// mountains
K=`Ω\`∂Tº\`„UõéÖD;oêN∏W˘Ãæaæaæaª\`º\`∑V∏V∏WΩaøb"pN”œWüHÜD,R2FQ©âC~0+@”Å”^∫\\/7`.match(/.{2}/g),

// forests 
L = `\\ÜCOVn;$~ÀëA2:ry~\r

|c{{,}RK^BI;OFOG<LET6ãc
[<OMREOWOK[ODMWT4C~DH!xiCE0Kk
~-W:2)jz~ãú*ubUD4dJ~áå"1i
j[KCY~”ÇY~¡jR!
p~Ë¶1Zr~∆h!yi~ê7	yYA~ÜA!xi~©VI[}*~@q	b9~*zq!<~EtY~híiYciYaSj[:#y5~P≥Zkbi#*`.split("~"),

// seas
M = `D/ 3?}F#I)L$AM7o$o:m/i;T#R&L.wP\r$:+.G>=C$D'd?gImNADR2W<N:m\`A
"#uo,f7j?kBl?kJmIpKycl,j(qP%* GM"F)I*F/J'I*Q<U4_;V	ky}	4}}}q\`p^,`.match(/[^]{3}/g);

// ONLOAD
// ======

// This onload function makes all the var names minifiable and waits for the fonts to load.
onload = function(){

// GLOBALS
// =======

// DATA
// ====

// by order of drawing:

// 0: seas
// 1: countries
// 2: us states
// 3: territories
// 4: deserts
// 5: forests
// 6: lakes
// 7: streams
// 8: capitals
// 9: us capitals
// 10: volcanoes
// 11: mountains
// 12: places
// 13: flags

var
datasets = [

  // 0: seas
  [
    `SEA`,                  // dataset name
    
    // names
    `Mediterranean seaGulf of mexicoEnglish channelBering seaAdriatic seaAegean seaBlack seaNorth seaRed seaSea of japanPhilippine seaEast china seaSouth china seaAral seaCaspian seaDead seaCoral seaGulf of alaskaCaribbean seaSargasso seaBaltic seaIrish seaCeltic seaLigurian seaTyrrhenian seaGulf of thailandJava seaTimor seaGulf of guineaPersian gulfArabian seaBarents seaGreenland seaGreat australian bightNorwegian seaHudson bayJames baySea of okhotskSeto inland seaBeibu gulfSulu seaCelebes seaBohol seaFlores seaBanda seaArafura seaTasman seaYellow seaBohai seaGulf of carpentariaBaffin bayGulf of st lawrenceGulf of bothniaSea of azovIonian seaMirtoon seaGulf of sidraMarmara seaSea of creteGulf of adenGulf of omanBay of bengalKara seaBeaufort seaAmundsen gulfChukchi seaLaptev seaEast siberian seaAmundsen seaWeddell seaRoss seaGulf st vincentSpencer gulfSalton sea`.split(/(?=[A-Z])/),

    M,                      // center and radius for each sea (2b + 1b)
    [...Array(74).keys()],  // questions not asked yet (it's an array from 0 to N = 74)
    3,                      // how many bytes represent each item
    1,                      // fill color (0 = none, 1 = transparent = highlightable)
    0,                      // stroke color (0 = none)
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    16,                     // diststep
  ],

  // 1: countries
  [
    `COUNTRY`,              // dataset name
    
    // names
    A=`RuRussiaMoscowCnChinaBeijingCaCanadaOttawaFrFranceParisDzAlgeriaAlgiersArArgentinaBuenos airesAuAustraliaCanberraAtAustriaViennaBeBelgiumBrusselsBrBrazilBrasiliaBgBulgariaSofiaAeUnited arab emiratesAbu dhabiClChileSantiagoHrCroatiaZagrebCuCubaHavanaCzCzechiaPragueDkDenmarkCopenhagenEcEcuadorQuitoEgEgyptCairoEeEstoniaTallinnNoNorwayOsloFiFinlandHelsinkiDeGermanyBerlinGrGreeceAthensHuHungaryBudapestEsSpainMadridChSwitzerlandBerneGbUnited kingdomLondonIsIcelandReykjavikInIndiaNew delhiIdIndonesiaJakartaIrIranTehranIqIraqBaghdadIeIrelandDublinIlIsraelJerusalemItItalyRomeJmJamaicaKingstonJpJapanTokyoLbLebanonBeirutLtLithuaniaVilniusLuLuxembourgLuxembourgMkMacedoniaSkopjeMgMadagascarAntananarivoMxMexicoMexico cityMcMonacoMonacoMaMoroccoRabatGyGuyanaGeorgetownLyLibyaTripoliNpNepalKathmanduNlNetherlandsAmsterdamNzNew zealandWellingtonKpNorth koreaPyongyangPsPalestineJerusalemPyParaguayAsuncionPePeruLimaPhPhilippinesManilaPlPolandWarsawPtPortugalLisbonRoRomaniaBucharestQaQatarDohaSaSaudi arabiaRiyadhSgSingaporeSingaporeSkSlovakiaBratislavaSiSloveniaLjubljanaZaSouth africaPretoriaKrSouth koreaSeoulSeSwedenStockholmTwTaiwanTaipeiTnTunisiaTunisTrTurkeyAnkaraUaUkraineKievUyUruguayMontevideoUsUsaWashington dcVeVenezuelaCaracasVaVatican cityVatican cityVnVietnamHanoiAfAfghanistanKabulAdAndorraAndorra la vellaAlAlbaniaTiranaByBelarusMinskBaBosniaSarajevoBfBurkina fasoOuagadougouCfCentral african republicBanguiCmCameroonYaoundeCdDemocratic republic of congoKinshasaCiCote d'ivoireYamoussoukroCrCosta ricaSan joseCoColombiaBogotaBoBoliviaLa pazCvCape verdePraiaCyCyprusNicosiaTgTogoLomeBjBeninPorto novoKhCambodiaPhnom penhDmDominicaRoseauCgCongoBrazzavilleDoDominican republicSanto domingoGaGabonLibrevilleGqEquatorial guineaMalaboGtGuatemalaGuatemala cityHtHaitiPort-au-princeHnHondurasTegucigalpaJoJordanAmmanKzKazakhstanAstanaXkKosovoPristinaKwKuwaitKuwait cityLaLaosVientianeKeKenyaNairobiMyMalaysiaKuala lumpurMlMaliBamakoMtMaltaVallettaMdMoldovaChisinauPkPakistanIslamabadPaPanamaPanama citySmSan marinoSan marinoSnSenegalDakarRsSerbiaBelgradeScSeychellesVictoriaSoSomaliaMogadishuLkSri lankaColomboSdSudanKhartoumTzTanzaniaDodomaThThailandBangkokYeYemenSanaaZwZimbabweHarareAgAntigua & barbudaSt john'sAmArmeniaYerevanAzAzerbaijanBakuAoAngolaLuandaBsBahamasNassauBhBahrainManamaBdBangladeshDhakaBbBarbadosBridgetownBzBelizeBelmopanBtBhutanThimphuBwBotswanaGaboroneBnBruneiBandar seri begawanBiBurundiBujumburaTdChadN'djamenaKmComorosMoroniDjDjiboutiDjiboutiSvEl salvadorSan salvadorEtEthiopiaAddis ababaErEritreaAsmaraFjFijiSuvaGmGambiaBanjulGeGeorgiaTbilisiGhGhanaAccraGdGrenadaSt george'sGnGuineaConakryGwGuinea-bissauBissauKiKiribatiTarawaKgKyrgyzstanBishkekLvLatviaRigaLsLesothoMaseruLrLiberiaMonroviaLiLiechtensteinVaduzMwMalawiLilongweMvMaldivesMaleMhMarshall islandsMajuroMrMauritaniaNouakchottMuMauritiusPort louisFmMicronesiaPalikirMnMongoliaUlan batorMeMontenegroPodgoricaMzMozambiqueMaputoMmMyanmarNaypyidawNaNamibiaWindhoekNrNauruYarenNiNicaraguaManaguaNeNigerNiameyNgNigeriaAbujaOmOmanMuscatPwPalauMelekeokPgPapua new guineaPort moresbyRwRwandaKigaliKnSt kitts & nevisBasseterreLcSt luciaCastriesVcSt vincent & grenadinesKingstownWsSamoaApiaStSao tome & principleSao tomeSlSierra leoneFreetownSbSolomon islandsHoniaraSsSouth sudanJubaSrSurinameParamariboSySyriaDamascusTjTajikistanDushanbeTlTimor-lesteDiliToTongaNuku'alofaTtTrinidad & tobagoPort of spainTmTurkmenistanAshgabatTvTuvaluFunafutiUgUgandaKampalaUzUzbekistanTashkentVuVanuatuPort vilaZmZambiaLusakaCkCook islandsAvaruaNuNiueAlofiSzSwazilandMbabane`.split(/(?=[A-Z])/),
    
    C,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(199).keys()], // questions not asked yet (it's an array from 0 to N = 199)
    0,                      // how many bytes represent each item (0 = variable)
    `#080`,                 // fill color
    `#000`,                 // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    1,                      // position in name group
    8,                      // diststep
  ],

  // 2: us states
  [
    `US STATE`,             // dataset name
    
    // names
    B=`HawaiiHonoluluAlaskaJuneauWashingtonOlympiaCaliforniaSacramentoNevadaCarson cityNew mexicoSanta feFloridaTallahasseeIllinoisSpringfieldOhioColumbusRhode islandProvidenceSouth carolinaColumbiaTexasAustinMarylandAnnapolisNorth carolinaRaleighUtahSalt lake cityVirginiaRichmondWest virginiaCharlestonPennsylvaniaHarrisburgConnecticutHartfordAlabamaMontgomeryNebraskaLincolnColoradoDenverGeorgiaAtlantaMichiganLansingNorth dakotaBismarckMontanaHelenaArizonaPhoenixArkansasLittle rockVermontMontpelierNew jerseyTrentonNew yorkAlbanyNew hampshireConcordMassachusettsBostonDelawareDoverOklahomaOklahoma cityIdahoBoiseOregonSalemIndianaIndianapolisIowaDes moinesKansasTopekaSouth dakotaPierreKentuckyFrankfortTennesseeNashvilleLouisianaBaton rougeMaineAugustaMinnesotaSt paulMississippiJacksonWisconsinMadisonMissouriJefferson cityWyomingCheyenne`.split(/(?=[A-Z])/),
    
    D,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(50).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#080`,                 // fill color
    `#000`,                 // stroke color
    2,                      // start byte for the path
    2,                      // name group size
    0,                      // position in name group
    6,                      // diststep
  ],

  // 3: territories
  [
    `TERRITORY`,            // dataset name
    
    // names
    `GreenlandAntarticaWestern saharaGibraltarGuadeloupeHong kongMartiniqueReunionGuamCayman islandsSt martinFrench polynesiaSt helenaSt barthelemyNew caledoniaPuerto ricoWallis & futunaFrench guianaGuernseyBritish indian ocean territoryMayotteSt pierre & miquelonAnguillaAmerican samoaFaroe islandsBermudaUs minor outlying islandsFrench southern territoriesBritish virgin islandsUs virgin islandsNetherlands antillesArubaAland islandsSouth georgiaBonaireBouvet islandCocos islandsCuracaoChristmas islandFalkland islandsHeard & mcdonald islandsIsle of manJerseyMacauNorthern marianasMontserratNorfolk islandPitcairn islandsJan mayenTokelauTurks & caicos islandsSvalbard`.split(/(?=[A-Z])/),

    E,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(52).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#080`,                 // fill color
    `#000`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 4: deserts
  [
    `DESERT`,               // dataset name
    
    // names
    `SaharaColorado plateauArabian desertGobiGreat victoriaSimpsonAtacamaSyrian desertGreat sandy desertNamibChihuahuan desertKalahariPatagonian desertKarakumSonoranKyzylkumTaklamakanTharGibsonDasht-e margoRegistanMojaveDasht-e kavirDasht-e loot`.split(/(?=[A-Z])/),

    I,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(24).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `rgba(255,255,255,.2)`, // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 5: forests
  [
    `FOREST`,               // dataset name
    
    // names
    `Amazon rainforestSumatra rainforestTaigaGreat lakes st lawrenceSierra nevadaMiombo woodlandsCongo basinKinabaluSundarbansDaintree rainforestXishuangbannaBialowieza primeval forestBlack forestVirgin komi forestsLacandon jungleTongassBosawas biosphere reserveAtlantic forestValdivian rainforest`.split(/(?=[A-Z])/),

    L,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(19).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `rgba(0,0,0,.1)`,       // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 6: lakes
  [
    `LAKE`,                 // dataset name
    
    // names
    `SuperiorLemanMichiganTiticacaVictoriaGreat bear lakeMalawiGreat slave lakeNicaraguaLoch nessTaal lakeBaikalOntarioPinatuboHuronTanganyikaErieWinnipegLadogaBalkhashOnegaCrater lakeReed flute caveEmerald lakeMirror lakeSpotted lake`.split(/(?=[A-Z])/),

    G,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(26).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    `#0af`,                 // fill color
    `#000`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 7: streams
  [
    `STREAM`,               // dataset name
    
    // names
    `AmazoneNileCongoNigerLoireZambezeIndusMississippiColoradoColumbiaUruguayYangtzeYellow riverXiUralDanubeRhinElbeMeuseRhoneSeineOrangeSenegalVoltaChariGambiaDraaBandamaTanaParanaYukonSao franciscoJubbaLimpopoRio grandeTocantinsOrinocoBrazosMackenzieMagdalenaFraserParnaibaSaint-laurentRio negroEssequiboLenaAmourMekongIenisseiObBrahmapoutreSalouenEuphratesAmou-dariaGangeSyr-dariaIrrawaddyKolymaTigrisIndiguirkaKouraGodavariKrishnaNarmadaRed riverAnadyrVolgaDnieperDonPechoraDniestrTagusVistuleDaugavaMurraySepik`.split(/(?=[A-Z])/),

    H,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(76).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    `#0df`,                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 8: capitals            
  [                         
    `CAPITAL`,              // dataset name
    A,                      // names
    C,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    3,                      // name group size
    2,                      // position in name group
    8,                      // diststep
  ],                        
  
  // 9: us capitals
  [
    `US CAPITAL`,           // dataset name
    B,                      // names
    D,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(50).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    2,                      // name group size
    1,                      // position in name group
    6,                      // diststep
  ],
  

  // 10: volcanoes
  [
    `VOLCANO`,              // dataset name
    
    // names
    `EtnaVesuviusPiton de la fournaiseMount peleeEyjafjallajokullSt helensKilaueaStromboliSanta mariaPinatuboYasurTaalAmbrymMerapiErta alePacayaErebusSakurajimaNyiragongoUlawunMauna loaGalerasKrakatoaTamboraNevado del ruiz`.split(/(?=[A-Z])/),

    J,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(25).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 11: mountains
  [
    `MOUNTAIN`,             // dataset name
    
    // names
    `Mount everestK2AnnapurnaFujiKilimanjaroMont blancPopocatepetlOlympusBroad peakCookLhotseMakaluCho oyuDhaulagiriManasluNanga parbatGasherbrum iGasherbrum iiShishapangmaKangchenjungaDenaliKirkjufellFitz royHuaElbrusMatterhornEl capitanGrand tetonLicancaburTre cime de lavaredoBen nevisRainierKinabaluHuangKailashBanff`.split(/(?=[A-Z])/),

    K,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(36).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 12: places
  [
    `PLACE`,                // dataset name
    
    // names
    `Cape canaveralChrist redeemerGreat chinese wallGreat sphinxEiffel towerTower of pisaSagrada familiaBig benStatue of libertyForbidden cityGiza pyramidsPalace of versaillesAcropolisTrevi fountainKremlinAtomiumLascaux cavesMont st michelPiazza san marcoWashington dcGrand canyonMillau bridgeRock of gibraltarEmpire state buildingHollywood signTimes squareLouvre museumWhite houseFlorence cathedralLas vegasMadrid palaceCentral parkSistine chapelPiazza del campoMachu picchuBurj al arab hotelSt peter basilicaCapitol hillLuxor templeGolden gate bridgeBurj khalifaAlcatrazEphesusManneken pisMount eden craterNorth capeSt basil cathedralVictoria fallsGreat buddha of kamakuraLotus templeColosseumAbu simbelPetronas twin towersYellowstoneNiagara fallsTaj mahalMeccaAuschwitzStonehengeMount rushmorePentagonCape of good hopeOpera houseParc guellPompeiiWaterlooEaster islandEvergladesCloud gateRialto bridgeWillis towerLittle mermaidTower bridgeBlue mosqueNevado mismiTable mountainMinaret of jamAngkor watFaisal mosqueNeuschwanstein castleGolden temple of amritsarAl aqsa mosqueTemple of besakihChichen itzaBran castleHagia sophiaUluruBrandenburg gateBlue domed churchCheyenne mountainKiyomizu-deraPetraTombouctouKultury i nauki palaceNull island`.split(/(?=[A-Z])/),
    
    F,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(95).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 13: flags
  [
    `COUNTRY`,              // dataset name (not `flags` because the game will say `find this country:`)
    A,                      // names
    C,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ]
],

c = a.getContext`2d`,                 // canvas context2d
flags = 1,                              // enable flags
lastdataset = 3,                        // previous dataset
scores = [],                            // scores for each question
questions,                              // total questions (chosen by player)
score,                                  // final score
random,                                 // random()
itemname,                               // current item name
error,                                  // current error
item,                                   // current item index
items,                                  // current list of questions
itemindex,                              // current item index
nameparts,                              // current item name parts
dataset,                                // current dataset
ds,                                     // dataset being drawn
us,                                     // USA question
time,                                   // time to answer each question
interval,                               // interval to load the flags
tmp,                                    // array returned by traceitem(): [mindist, x, y]
//extraxoffset,                           // X adjustment for drawing polygons
state = 0,                              // 0 = title screen
question = 0,                           // current question number
mode = 0,                               // 0 = highest score / 1 = `least errors`
errorsum = 0,                           // error sum (in mode 1)
timer = 0,                              // countdown (ms)
timeout = 0,                            // time out (took too long to answer)

// FUNCTIONS
// =========


// Draw a screen
draw = function(){

  // Reset canvas, except for feedback state
  a.width = 1020;
  
  // Black background except on map and feedback
  if(state != 3 && state != 4){
    c.fillStyle = `#123`;
    c.fillRect(0, 0, 1020, 1020);
  }

  // Title screen (0)
  if(!state){
    
    // Stars
    c.fillStyle = `#fff`;
    for(i = 999; i--;){
      c.beginPath();
      c.arc(Math.random() * 1020, Math.random() * 1020, Math.random(), 0, 7);
      c.fill(); 
    }
    
    // 2
    c.font = `600px i`;
    c.fillStyle = `#07d`;
    c.fillText(2, 680, 530);
    
    
    c.font = `50px i`;
    c.fillText(`\u{1f312}`, 720, 200);
    
    // Emoji
    c.font = `230px i`;
    c.fillText(`\u{1f30d}`, 225, 410);
    
    // GE ... QUIZ
    c.fillStyle = `#fff`;
    c.fillText(`GE     QUIZ`, 50, 415);
  }
  
  // Propose to load flags on Windows and Linux (6)
  else if(state == 6){
  
    // Load flag emoji font
    //b.style.fontFamily = `f,i`;

    c.font = `110px f`;
    
    c.fillText(`\u{1f1fa}\u{1f1f8}`, 450, 360);
  
    c.fillStyle = `#fff`;
    c.font = `110px i`;
    
    c.fillText(`Loading flags`, 200, 150);
    c.fillText(`\u25b8OK     \u25b8skip`, 210, 480);
    
    c.font = `40px i`;
    
    c.fillText(`Click OK when you see a flag below:`, 220, 220);
  }
  
  // Menu (1)
  else if(state == 1){
    
    c.fillStyle = `#fff`;
    c.font = `110px i`;
    
    c.fillText(`Game mode`, 60, 150);
    
    c.font = `70px i`;
    
    c.fillText(`\u25b8High score`, 50, 280);
    c.fillText(`\u25b8Endless`, 50, 460);
    
    c.font = `35px i`;
    
    c.fillText(`Answer 25 to 1000 questions and get a grade`, 110, 330);
    c.fillText(`Play until you reach 50,000km of errors`, 110, 510);

  }
  
  // High score submenu (7)
  else if(state == 7){
  
    c.fillStyle = `#fff`;
    
    c.font = `60px i`;
    
    c.fillText(`\u25b825 questions`, 50, 170);
    c.fillText(`\u25b850 questions`, 50, 300);
    c.fillText(`\u25b8100 questions`, 50, 430);
    
    c.fillText(`\u25b8250 questions`, 530, 170);
    c.fillText(`\u25b8500 questions`, 530, 300);
    c.fillText(`\u25b81000 questions`, 530, 430);
  }
  
  // Choose a question (2)
  else if(state == 2){
  
    // Pick a dataset
    // --------------
      
    // First 3 questions: country (1), capital (8), place (12), territory (3), sea (0)
    if(question < 5){
      lastdataset = dataset = [1,8,12,3,0][question];
    }

    // For all the other questions, the dataset is picked randomly
    else {
      dataset = lastdataset;
      
      // Try 999 times to pick another dataset than the previous one, then abandon and take the same
      for(i = 0; i < 999; i++){
      
        random = Math.random();
      
        // 30% chance to choose country, capital or place (10% each)
        if(random < .1) dataset = 1;
        else if(random < .2) dataset = 8;
        else if(random < .3) dataset = 12;
        
        // 70% chance to choose one of the 11 other datasets (or 10 if flags are disabled)
        else {
          
          // Flags: 70% / 11 = 6.4% for datasets 0 and 4-11
          // No flags: 70% / 10 = 7% for datasets 0 and 4-10
          dataset = (4 + (~~((random - .3) / (flags ? .064 : .07)))) % (flags ? 14 : 13);
        }

        // If we found a new dataset not empty: keep it
        // Also, avoid US capitals before question 20
        if(dataset != lastdataset && datasets[dataset][3].length && !(question < 20 && dataset == 9)){
          break;
        }
        
        // Else, take the previous one (it is for sure not empty but it was avoided until now)
        dataset = lastdataset;
      }
      
      // Save this dataset to avoid picking it again
      lastdataset = dataset;
    }
    //dataset = 2;
    
    items = datasets[dataset][3];
    
    
    // If no question left or 50000km attained in mode 1: go to score screen
    if(question >= questions || !items.length || errorsum > 50000){
      state = 5;
      draw();
      return;
    }
    
    // Pick a question
    // ---------------
    
    // Pick one of the first N questions not asked yet (N = number of questions asked)
    // This ensures a progressive difficulty
    // For the first 3 questions, pick between the first 30 (they're all easy, and it makes the games less repetitive)
    item = ~~(Math.random() * Math.min(question < 3 ? 30 : question, items.length)); 
    
    itemindex = items[item];
    
    // Save item's name
    itemname = 
      datasets[dataset][1] // names
      [datasets[dataset][8] * itemindex + datasets[dataset][9]] // name index
      .toUpperCase();

    // Remove that question from the array of available questions
    items.splice(item, 1);
    
    // Display everything
    // ------------------
    
    c.fillStyle = `#fff`;
    
    // question number
    c.font = `40px i`;
    c.fillText(`Question ` + (question + 1) + (!mode ? (`/` + questions) : ``), 30, 50);
    
    // Errors so far
    if(mode == 1 && errorsum){
      c.fillText(`Errors: ` + errorsum + `km`, 30, 100);
    }
    
    c.textAlign = `center`;
    c.font = `70px i`;
    
    // Find this ... :
    c.fillText(`FIND THIS ` + datasets[dataset][0] + `:`, 512, 280);
    
    // arrow
    c.fillText(`\u25b8`, 950, 550);
    
    // Question
    
    // Flag
    if(dataset == 13){
      c.font = `200px f`;
      c.fillText(itemname = String.fromCodePoint(0x1F1E6 + itemname.charCodeAt() - 65, 0x1F1E6 + itemname.charCodeAt(1) - 65), 512, 470);
    }
    
    // Name
    else {
      c.font = `99px i`;
      nameparts = itemname.match(/.{1,16}( |$)/g);
      
      c.fillText([nameparts[0]], 510, 400);
      c.fillText([nameparts[1]], 510, 500);
      
    }
  }
  
  // Map (3)
  else if(state == 3){
  
    // Detect US question
    us = dataset == 2 || dataset == 9;
    
    // Trace datasets 1-7 (scaled if US state or US capital)
    for(ds = 1; ds < 8; ds++){
    
      // US polygons are 1.5px more to the left
      //extraxoffset = ds == 2 ? 0 : -1.5;
      
      // Trace
      // Trace in black every 10 questions
      trace(ds, us ? 3.9 : 1, us ? -254 : -4, us ? -350 : 0, (question % 9 > 7 ? "#000" : 0), (question % 9 > 7 ? "#000" : 0) );
    }
    
    // Repeat the question
    c.fillStyle = `#000`;
    c.fillRect(0, 0, 1020, 60);
    
    c.fillStyle = `#fff`;
    c.font = `40px i,f`;
    c.fillText(datasets[dataset][0] + `: ` + itemname, 10, 45);
    
    timer = 20000;
    timeout = 0;

  }
  
  // Feedback (4)
  else if(state == 4){

    // If the item is a sea (dataset 0), trace it highlighted in yellow before the rest of the map
    if(!dataset){
      tmp = tracesea(M[itemindex]);
    }
    
    // Trace the datasets 1-7
    for(ds = 1; ds < 8; ds++){
    
      // US polygons are 1.5px more to the left
      //extraxoffset = ds == 2 ? 0 : -1.5;
      
      // Trace
      trace(ds, us ? 3.9 : 1, us ? -254 : -4, us ? -350 : 0, (question % 9 > 7 ? "#000" : 0), (question % 9 > 7 ? "#000" : 0));
    }
    
    // If the item is a polygon, trace it highlighted on top of the map
    if(dataset){
    
      // Special case if the country is USA: draw the USA set
      if((dataset == 1 || dataset == 13) && itemindex == 72){
        tmp = trace(2, 1, -4, 0, "#ff0", "#db0");
      }
      
      else {
      
        //extraxoffset = dataset == 2 ? -4 : -5.5;
      
        tmp = traceitem(
          datasets[dataset][2][itemindex],// polygon
          datasets[dataset][7],           // start byte
          datasets[dataset][4],           // bytes to draw
          datasets[dataset][10],          // diststep
          dataset == 7 ? 0 : `#ff0`,      // fill (except for streams)
          `#db0`,                         // stroke
          us ? 3.9 : 1,                   // scale
          us ? -254 : -4,                 // x offset
          us ? -350 : 0,                  // y offset
          5,                              // line width
        );
      }
    }
    
    // Trace the error distance (if any), including offscreen (+/- 1020px)
    if(tmp[0] > 4 && !timeout){
      c.beginPath();
      c.fillStyle = `red`;
      c.arc(X,Y,10,0,7);
      c.fill();
      c.beginPath();
      c.setLineDash([15, 5]);
      c.strokeStyle = `red`;
      c.lineWidth = 5;
      c.moveTo(X,Y);
      c.lineTo(tmp[1],tmp[2]);
      
      c.moveTo(X-1020,Y);
      c.lineTo(tmp[1]-1020,tmp[2]);
      
      c.moveTo(X+1020,Y);
      c.lineTo(tmp[1]+1020,tmp[2]);
      
      c.stroke();
      c.setLineDash([]);
    }
    
    c.fillStyle = `#017`;
    c.font = `80px i`;
    c.strokeStyle = `#fff`;
    c.lineWidth = 2;
  
    // Timeout
    if(timeout){
      c.fillText(`Time out!`, 400, 530);
      c.strokeText(`Time out!`, 400, 530);
      time = 100;
    }
    
    // Perfect
    else if(tmp[0] < 5){
      c.fillText(`Perfect!`, 400, 530);
      c.strokeText(`Perfect!`, 400, 530);
    }
    
    // Error
    else{
    
      // Scale: 100px = 3000km
      // 1px = 30km      
      error = ~~(tmp[0] * .3) * 100;
      if(mode == 1){
        errorsum += error;
      }
      
      c.fillText(error + `km away!`, 300, 530);
      c.strokeText(error + `km away!`, 300, 530);
    }
    
    // Repeat the question + the country if the question was a capital or a flag
    c.fillStyle = `#000`;
    c.fillRect(0, 0, 1020, 60);
    
    c.fillStyle = `#fff`;
    c.font = `40px i,f`;
    c.fillText(datasets[dataset][0] + `: ` + itemname + (dataset == 8 || dataset == 13 ? ` (` + A[itemindex * 3 + 1] + `)` : dataset == 9 ? ` (` + B[itemindex * 2] + `)` : ``).toUpperCase(), 10, 45);
    
    // Score for each question: 100 - time (in seconds) - (error in km) / 50
    scores[question] = Math.max(0, 100 - time - ~~(error / 50));
    
    timer = 3000;
    
  }
  
  // Score (5)
  else if(state == 5){
    
    // Max score
    if(!mode){
      score = ~~(scores.reduce((a,b)=>a+b) / scores.length) + `%`;
    }
    
    // Min errors
    else {
      score = question + ` question` + (question > 1 ? "s" : "");
    }
    
    
    
    c.fillStyle = `#fff`;
    c.textAlign = `center`;
    c.font = `90px i`;
    
    c.fillText(`Score: ` + score, 510, 250);
    

    c.font = `40px i`;
    c.fillText(`\u25b8share`, 510, 400);
    c.fillText(`\u25b8replay`, 510, 500);

  }
},


// Convert a latin-1 char to int
latin2int = function(i){
  if(i){
    J = i.charCodeAt();
    return (6E4 < J ? 0 : 255 < J ? `ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü`.indexOf(i) + 128 : J);
  }
},

// Draw an item (point / polygon)
// and return an array containing the distance and x/y coordinates of the point that's the closest to the click coordinates (X/Y)
traceitem = function(polygon, startbyte, bytes, diststep, fill, stroke, scale, xoffset, yoffset, linewidth){

  var j, k, x, y, tmpx, tmpy, x0, y0, J, A, D, dist, ret = [0], mindist = 6E4;
  
  // Separate the islands of the polygon (using char U+127)
  polygon = polygon.slice(startbyte).split``;
  
  // For each island (or just the first island if a number of bytes is specified)
  for(k = bytes ? 1 : polygon.length; k--;){
    
    // For each point of the island (or the number of bytes specified)
    for(j = 0; j < (bytes ? bytes : polygon[k].length); j++){

      // Begin the path with the start coordinates (X/Y, encoded in 1 char each)
      if(!j){
        c.beginPath();
        x0 = x = (latin2int(polygon[k][j]) * diststep);
        y0 = y = (latin2int(polygon[k][j + 1]) * diststep / 2);
        c.moveTo(tmpx = x / 2 * scale + xoffset, tmpy = y / 2 * scale + yoffset + 65);
        
        // Save the point if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen polygons (except for US) to see if they're closer
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
        
        // Trace a little black square at the start coordinates, to make the little islands visible
        c.fillStyle = stroke;
        if(stroke && fill){
          c.fillRect(x / 2 * scale + xoffset, y / 2 * scale + yoffset + 65, 1, 1);
        }
        
        // Highlight (linewidth = 5) if the target is a point: circle the point in yellow
        if(linewidth == 5 && ((polygon.length == 1 && polygon[0].length < 5) || bytes == 2)){
          c.arc(x/2 * scale + xoffset, y/2 * scale + yoffset + 65, 8, 0, 7);
        }
        
        j++;
      }
      
      // Continue the path with a distance and an angle encoded together in 1 char
      else {
        J = latin2int(polygon[k][j]);
        A = -((J >> 3) - 1) * Math.PI / 8,
        D = (J & 7) * diststep + diststep,
        x = Math.floor(x + D * Math.cos(A))
        y = Math.floor(y + D * Math.sin(A))
        c.lineTo(tmpx = x / 2 * scale + xoffset, tmpy = y / 2 * scale + yoffset + 65);

        // Save the center if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen paths
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
      }
    }
    
    // If the polygon is filled (i.e. not a stream), close the path
    if(fill){
      c.lineTo(x0/2 * scale + xoffset, y0/2 * scale + yoffset + 65);
    }
    
    // Stroke the path (0.5px wide for the streams, 5px if highlighted);
    c.strokeStyle = stroke;
    c.lineWidth = linewidth == 5 ? 5 : fill ? scale > 1 ? 4 : linewidth : .5;
    if(stroke){
      c.stroke();
    }
    
    // Fill the path (poles are colored in white except during highlight)
    if(fill){
      c.fillStyle = (linewidth < 5 && (question % 9 < 8) && (y0 < 80 || y0 > 900)) ? "#fff" : fill;
      c.fill();
    }
    
    // Check if the last click was inside the polygon
    if(c.isPointInPath(X, Y)){
      ret = [mindist = 0];
    }
  }
  
  // Adjust the error distance according to the scale
  ret[0] /= scale;
  
  return ret;
},

tracesea = function(sea){
  var x, y, tmpx, tmpy, r, dist, mindist = 6E4, ret;
  x = latin2int(sea[0]) * 16;
  y = latin2int(sea[1]) * 16 / 2;
  r = latin2int(sea[2]) * 16;
  c.beginPath();
  c.arc(tmpx = x / 2, tmpy = y / 2 + 65, r / 2, 0, 7);
  c.arc(x / 2 - 1020, y / 2 + 65, r / 2, 0, 7);
  c.arc(x /2 + 1020, y / 2 + 65, r / 2, 0, 7);
  
  // Save the center if it's the closest to the click coordinates
  dist = Math.hypot(X - tmpx, Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx, tmpy];
  }
  
  // Also, try offscreen seas
  dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx - 1020, tmpy];
  }
  
  dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx + 1020, tmpy];
  }
  
  c.fillStyle = `#ff0`;
  c.fill();
  if(c.isPointInPath(X,Y)){
    ret = [mindist = 0];
  }
  
  return ret;
},

// Draw a dataset
trace = function(ds, scale, xoffset, yoffset, fill, stroke){

  var tmp, ret, mindist = 99999;
  ds = datasets[ds];
  
  // Trace each item with the right params
  for(i in ds[2]){
    tmp = traceitem(ds[2][i], ds[7], ds[4], ds[10], fill || ds[5], stroke || ds[6], scale, xoffset, yoffset, 2);
    if(tmp[0] < mindist){
      ret = tmp;
      mindist = tmp[0];
    }
  }
  return ret;
},


// Music
music = function(){
var audio = new AudioContext,
gain = audio.createGain(),
note,
notes,
oscillator;
for(note in notes = `










cccc\r
ccc










cccc
ccc


\r
ccc
c\rcc`){
  oscillator = audio.createOscillator(),
  oscillator.connect(gain),
  gain.connect(audio.destination);
  oscillator.start(note * .2);
  oscillator.frequency.setValueAtTime(415 * 1.06 ** (13 - notes.charCodeAt(note)), note * .2),
  gain.gain.setValueAtTime(.5, note * .2); 
  gain.gain.setTargetAtTime(.001, note * .2 + .18, .005)
  oscillator.stop(note * .2 + .19);
}
setTimeout(music, 30500);
};
  
// EVENTS
// ======
  
// Mouseup, touchend
onmouseup = function(e){

  //console.log(state);

  // Convert pointer coords to canvas intrinsic coords (X, Y).
  // Measure canvas size on state
  w = a.offsetWidth;
  
  // Mobile
  if(e.changedTouches){
    X = e.changedTouches[0].pageX * 1020 / w;
    Y = e.changedTouches[0].pageY * 1020 / w;
  }
  
  // Desktop
  else{
    X = e.pageX * 1020 / w;
    Y = e.pageY * 1020 / w;
  }
  
  // On title screen (0)
  if(!state){

    // detect OS with bad flag support (Win / Linux)
    state = navigator.userAgent.match(/Mac|iOS|And/) /*|| localStorage.gq2*/ ? 1 : 6;
  }
  
  // On flags screen (6)
  else if(state == 6){
  
    // Skip
    if(X > 510){
      flags = 0;
    }
    
    // Save flag agreement
    //else {
    //  localStorage.gq2 = 1
    //}
    
    state = 1;
  }
  
  // On mode screen (1)
  else if(state == 1){
  
    // Least errors
    if(Y > 370) {
      questions = flags ? 1123 : 925;
      mode = 1;
      state = 2;
    }
    
    // High score
    else {
      state = 7;
    }
  }
  
  // On High score submenu (7)
  else if(state == 7){
    if(Y > 350){
      questions = 100;
    }
    else if(Y > 210){
      questions = 50;
    }
    else{
      questions = 25;
    }
    
    if(X > 500){
      questions *= 10;
    }
    
    state = 2;
  }
  
  // On question screen (2)
  else if(state == 2){
    
    // Start timer
    //time = new Date;
    
    // Go to map
    state = 3;
  }
  
  // On map (3)
  else if(state == 3){
  
    // Stop timer, save time elapsed in seconds
    time = 20 - timer / 1000;
    
    // Go to feedback
    state = 4;
  }
  
  // On feedback (4)
  else if(state == 4){
    question++;
    state = 2;
  }
  
  // On score screen (5)
  else if(state == 5){
    
    if(Y < 430){
    
      // Share
      open("//xem.github.io/geoquiz2/s/#"+[score,mode,questions]);
    }
    
    // Reload
    location = location;
    
  }
  
  draw();
  
};


// INIT
// ====

// Font polyfill
//b.style.fontFamily = `impact,i`;

// Remove Kosovo flag, because it can't be displayed properly on many browsers, even with a Web font.
datasets[13][3].splice(102, 1);

// Draw title screen
draw();

// MUSIC
// =====
music();

//window.dat = datasets;

// GAME LOOP (100ms)
setInterval(function(){
  
  //console.log("="+timer);
  
  if(timer){
    timer -= 100;
    //console.log(timer);
  }

  // Redraw flags screen every 100ms to draw the flag when the font is finally loaded 
  if(state == 6){
    draw();
  }
  
  // Time limit on map screen (20s)
  else if (state == 3){
    //c.fillStyle = "#000";
    //c.fillRect(940,0,70,60);
    //c.beginPath();
    c.beginPath();
    c.fillStyle = "#ff0";
    c.moveTo(970, 30);
    c.lineTo(970, 10);
    c.arc(970, 30, 20, -1.5, -1.5 - 6.3 * (timer / 20000));
    c.fill();
    if(!timer){
      state = 4;
      timeout = 1;
      draw();
    }
  }
  
  // Auto skip on feedback screen (2s)
  else if(state == 4){
    if(!timer){
      state = 2;
      question++;
      draw();
    }
  }
  
  
}, 99);

}

</script>
<style>

/* The font "f" uses the Emoji fonts Noto Color emoji and Twemoji (for Windows) */
@font-face{font-family:f;src:url(//xem.github.io/geoquiz2/n.ttf),url(//xem.github.io/geoquiz2/t.ttf)}

/* The font "i" uses the local font Impact and a fallback for old OS that may not have it */
@font-face{font-family:i;src:local(impact),url(//xem.github.io/geoquiz2/i.ttf)}

/* Global style */
*{margin:0;background:#123;cursor:crosshair;width:100%;overflow:hidden;max-width:177vh;font-family:i}

/* Canvas radial background */
#a{background:radial-gradient(#7DF 50%,#0af)}